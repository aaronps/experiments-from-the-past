<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><title>Canvas Speed</title><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script type="text/javascript">

var _canvas = null;
var ctx = null;

var visual_area_width = 800;
var visual_area_height = 600;

var visual_area_max_x = visual_area_width - 1;
var visual_area_max_y = visual_area_height- 1;

var visual_area_half_width  = (visual_area_width /2) - 1;
var visual_area_half_height = (visual_area_height/2) - 1;

var screen_width = 640;
var screen_height= 480;

var screen_max_x = screen_width - 1;
var screen_max_y = screen_height- 1;

var x_ratio = screen_max_x / visual_area_max_x;
var y_ratio = screen_max_y / visual_area_max_y;

var cub_data =
{
	vertex:
	[
		[ 30, 30,-30], [ 30, 30, 30], [-30, 30, 30], [-30, 30,-30], // far face
		[ 30,-30,-30], [ 30,-30, 30], [-30,-30, 30], [-30,-30,-30] // near face
	],

	faces: // squares for now
	[
		[0, 1, 2, 3], // top cover
		[4, 5, 6, 7], // bottom
		[0, 1, 5, 4], // right side
		[0, 3, 7, 4], // back side
		[3, 2, 6, 7], // left side
		[1, 2, 6, 5], // that front side
	]
};

var cub = 
{
	data: cub_data,
	location: [ -200.0, 20.0, 1000.0],
	rotation: [ 1.0, 1.0, 1.0],
	sin_rotation: [ 0.0, 0.0, 0.0],
	cos_rotation: [ 0.0, 0.0, 0.0],
	
	rotated_vertex: [],
	translated_vertex: [],
	screen_pixel: [],
	
}

var cub2 = 
{
	data: cub_data,
	location: [ 20.0, 20.0, 400.0],
	rotation: [ 0.0, 2.0, 2.0],
	sin_rotation: [ 0.0, 0.0, 0.0],
	cos_rotation: [ 0.0, 0.0, 0.0],
	
	rotated_vertex: [],
	translated_vertex: [],
	screen_pixel: [],
	
}


function pre_calc_rotation(obj)
{
    var angles = obj.rotation;
    var sins = obj.sin_rotation;
    var coss = obj.cos_rotation;
    sins[0] = Math.sin(angles[0]);
    sins[1] = Math.sin(angles[1]);
    sins[2] = Math.sin(angles[2]);
    coss[0] = Math.cos(angles[0]);
    coss[1] = Math.cos(angles[1]);
    coss[2] = Math.cos(angles[2]);
}

function calc_rotation(obj)
{
    var sins = obj.sin_rotation;
    var coss = obj.cos_rotation;
    var orig_vertex = obj.data.vertex;
    var rotated_vertex = obj.rotated_vertex;

    var x = 0.0;
    var y = 0.0;
    var z = 0.0;
    
    var tx = 0.0; // TEMPORAL HOLDERS
    var ty = 0.0;
    var tz = 0.0;
    
    var len = orig_vertex.length;
    
    for ( var v = 0; v < len; ++v )
    {
        x = orig_vertex[v][0] * (-1.0);
        y = orig_vertex[v][1];
        z = orig_vertex[v][2];
            
        //x = (-1.0) * x;
        
        tx = (coss[0] * x) - (sins[0] * z);
        ty = (coss[1] * y) - (sins[1] * tx);
        tz = (sins[0] * x) + (coss[0] * z);
        
        x = (coss[1] * tx) + (sins[1] * y);
        y = (sins[2] * tz) - (coss[2] * ty);
        z = (coss[2] * tz) - (sins[2] * ty);

        rotated_vertex[v] = [x, y, z];
    }
}

function calc_translation(obj)
{
    var orig_vertex = obj.rotated_vertex;
    var translated_vertex = obj.translated_vertex;

    var px = obj.location[0];
    var py = obj.location[1];
    var pz = obj.location[2];
    
    var len = orig_vertex.length;
    
    for ( var v = 0; v < len; ++v)
    {
        translated_vertex[v] = 
        [
            orig_vertex[v][0] + px,
            orig_vertex[v][1] + py,
            orig_vertex[v][2] + pz,
        ];
    }
}

// also gives the final screen pixel

function calc_projection(obj)
{
    var vertex = obj.translated_vertex;
    var screen_pixel = obj.screen_pixel;

    var vertex_z = 0.0;
    
    var d = 1600;
    var ver;

    var len = vertex.length;
    
    for ( var v = 0; v < len; ++v)
    {
        ver = vertex[v]
        vertex_z = ver[2];
        screen_pixel[v] = 
        [
            (((ver[0] * d)/vertex_z)+visual_area_half_width )*x_ratio,
            (((ver[1] * d)/vertex_z)+visual_area_half_height)*y_ratio
        ];
    }
}

function draw_faces(obj)
{
    var faces = obj.data.faces;
    var points = obj.screen_pixel;
    
    var segment = 0;
    
    var face;
    var max_f = faces.length;
    
    for ( var f = 0; f < max_f; ++f)
    {
        face = faces[f];
        for ( segment = 0; segment < 4; ++segment )
        {
            ctx.beginPath();
            ctx.moveTo(points[face[segment]][0], points[face[segment]][1]);
            ctx.lineTo(points[face[(segment+1)&3]][0], points[face[(segment+1)&3]][1])
            ctx.stroke();        
        }
    }
}


function do_start()
{
//    console.log("Will start in a second " + tests.length + " tests");

    _canvas = document.getElementById("c");
    ctx = _canvas.getContext("2d");
    
    
    var objs = [ cub, cub2 ];
    var num_n = objs.length;
    
    for ( var n = objs.length; --n >= 0; )
    {
        pre_calc_rotation(objs[n]);
        calc_rotation(objs[n]);
        calc_translation(objs[n]);
        calc_projection(objs[n]);

        draw_faces(objs[n]);
    }


//    console.log("Going to run test["+testid+"]: " + tests[testid].name );
}






</script>
  </head>
  <body onload="do_start()">
  <canvas id="c" width="640" height="480"></canvas>
  </body>
</html>
